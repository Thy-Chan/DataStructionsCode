* 《数据结构》课程设计题目
** 实验要求：
1、	程序实现采用C语言，每个题目只以一个文件实现，文件名要有学生姓名年级专业实验组序号，对源代码中的关键变量、结构类型要求有简要的注释说明，
例如：
for (i=1;i<=m;i++) a[i]=i;    //记录猴子号码，初始化
   j=1;                      //从第一只猴子开始报数。
2、	实验题目原则上要求在实验课结束时发送到老师邮箱
邮箱：1223732733@qq.com。
 
** 题目1：猴子选王（学时：3）
一堆猴子都有编号，编号是1，2，3 ...m，这群猴子（m个）按照1-m的顺序围坐一圈，从第1开始数，每数到第n个，该猴子就要离开此圈，这样依次下来，直到圈中只剩下最后一只猴子，则该猴子为大王。
要求：m及n要求从键盘输入，存储方式采用向量及链表两种方式实现该问题求解。 
思路：（该题其实是简单的约瑟夫问题，主要考察学生链表的掌握情况）
（1）链表实现：
存储结构 
struct Monkey
{
	int num;                                  //存放猴子号码
	struct Monkey *next;                      //指向下一位猴子
};
最后一只猴子，也就是第m只的next指向第一只猴子，这样就实现了循环链表：  
在报数时，即指向后一直猴子，p=p->next;  (p初始为第一只猴子，p 为struct Monkey * 类型)
报到n时，将报n的前一只猴子的next指针指向报n 的后一只猴子(也就是p前一只的next赋值为p->next;)；直到最后只剩一只猴子为止。
（2）向量实现：
将数组a[],  1--m分别初始化为1，表示m只猴子都在圈中，报数时，每次报到n的猴子(比如猴子i)，将a[i]赋值为0，则表示标号为i的猴子踢出圈中了。则每次报数时先判断a[i]是不是等于1，等于一表示报数，继续下一位报数；若不等于1，也就是等于0，表示该猴子已经踢出圈中了，则继续找，直到找到下一位可以报数的猴子。做m-1次踢出猴子的循环则就可以统计出1-m中哪一个是1的，则下标i表示该猴子的标号，即为猴王。
 
** 题目2 ：字符逆转（学时：3）
从键盘读入一个字符串，把它存入一个链表（每个结点存储1个字符），并按相反的次序将字符串输出到显示屏。
思路：（再次检测学生的链表以及指针的掌握情况）
采取结构体：
struct String
{
	struct String *last;   //指向该字符的上一个字符
	char s;
};
初始化第一个字符的p->last赋值为NULL；然后p->s存储字符； 然后读入的每一个字符，last都指向该字符的上一个字符，这样就实现了从尾部指向头部的单向链表，存储结束时，停留在输入时的最后一个字符，也就是倒叙的第一个，从p开始输出，依次执行：输出p->s; p=p->last;直到p等于NULL时结束。
 
 
** 题目3 ：工资核算（学时：3）
设有一个单位的人员工资有如下信息：name、department、 base pay、allowance、total。现从键盘输入一组人员工资数据并将它们存储到名为paydata的文件中；再从paydata取出工资数据并给每个人的base pay增加100元，增加后将工资数据显示于屏幕(每行1人)。
思路：（该题主要是考察文件录入和读出的掌握情况）
注意文件读写的格式以及各参数的意义：
FILE * fp;      //定义指向文件的指针变量fp
fopen(“a1”,”r”)    //表示打开名为“a1”的文件，使用文件方式为“读入”（r表示read，即读入）
文件使用方式	           含义	如果指定的文件不存在
“r”(只读)   	为了输入数据，打开一个已经存在的文本文件 	出错
“w”（只写）	为了输出数据，打开一个文本文件	建立新文件
“rb”（只读）	为了输入数据，打开一个二进制文件	出错
“wb”（只写）	为了输出书籍，打开一个二进制文件	简历新文件
“r+”（读写）	为了读和写，打开一个文本文件	出错
“w+”（读写）	为了渡河写，建立一个新的文本文件	简历新文件
“rb+”（读写）	为了读和写，打开一个二进制文本文件	出错
“wb+”（读写）	为了读和写，建立一个新的二进制文件	建立新文件

fclose(fp)              //关闭文件，fp表示文件指针
fgec(fp)        //从fp指向的文件读入一个字符    
fputc(ch,fp)    //把字符ch写到的文件指针变量fp所指向的文件中
fread（buffer,size,count,fp)
fwrite(buffer,size,count,fp)
buffer:是一个地址，对fread来说是存放从文件读入的数据的存储的地址；对fwrite来说，是要把次地址开始的存储区的数据向文件输出（以上指的都是起始地址）。
size：要读写的字节数；
count：要读写多少个数据项（每个数据项长度为size）
fp：FILE类型指针
其他的都是最基础的东西,将以上的文件的内容掌握即可。
 
** 题目4：满足条件的有序表生成（学时：3）
已知三个有序表A、B、C，它们皆由同一类元素构成，现要求对于表A作以下运算而获得有序表D：排出A中所有的既在B中又在C中出现的元素。另外该任务要求具有建立有序表功能以及输出有序表到屏幕的功能。
思路：（该题主要考察排序，查找，删除节点等知识）
要获得D，即删去A在B和C中的公共元素，在输出有序表
不妨先将A，B，C都排一下序，冒泡排序，选择排序，快排看个人习惯；
然后可以将B，C中的相同元素提取出来，由于B和C都是有序的，（假设从小到大），则取两个指针P1，P2，分别指向B和C的头结点，开始查找，如果P1的元素小于P2的元素，则P1后移；若相等，则存储起来（存在same中），P1,P2同时后移；若P1的元素大，则P2后移；直到B，C有一个先查找完终止。
将A中元素依次对照same,同样可以是P1，P2分别指向A和same第一个结点，因为B，C是有序的，所以same中的元素其实也是有序的（此处由小到大），若P1的元素小，则P1的元素存入D中，P1后移；若P1的元素和P2的元素相等，则P1后移（此处可能有同学会认为既然相等，应该P1，P2同时后移，但注意，A中可能会有P1这个字符多次，即P1的下一个结点可能还是同一个字符，若P2也后移了，则A中的该元素会被误存到D中）；若P2的元素小，则P2后移；直到有一个先结束。

 
** 题目5：一元多项式的减法（学时：6）
设有两个一元多项式A(x),B(x)，请完成运算A(x)+B(x)、A(x)-B(x)，要求多项式采用链表进行存储。另外该任务要求具有建立多项式链表以及输出多项式到屏幕的功能。
思路：（该题考察的是学生对链表合并的算法）
首先，按照正常的书写规则，读取时应该是从指数大的到指数小的存入，或者以防万一，可以在读入的时候加一个排序，即读入一对系数和指数时，看该指数与已经存入的指数的大小关系，插入到链表中，就可以保证链表是按指数降序的。
在进行加减法运算时，即将指数相同的相加（减），若系数加（减）完不等于0，则创建新结点存入运算后的系数以及指数。（给出的程序是加减一起做的，及指数相同的加减运算的系数都存取了，所以有系数为0的结点，不过咋输出时做了特殊处理）。
输出时应注意，按书写规则，如a1 x^n + a2 x^m + ……
若系数小于0，则不输出加号，若系数大于0，则除了第一项，都要额外输出加号；出现指数为1的只需输出ax的形式，而对于指数为0的，只需输出a即可。
 
** 题目6：床位分配（学时：6）
   DEADLINE: <2016-05-22 周日 11:00> SCHEDULED: <2016-05-15 周日 09:00>
某客店有N个等级的房间，第k级客房有A（k）个，每个房间有B（k）个单人床，以菜单调用方式设计为单身旅客分配床位以及离店时收回床位的程序。要求分配成功时，印出旅客姓名、年龄、性别、到达日期、客房等级、房间号及床位号；分配不成功时，允许更改房间等级，若不更改等级，印出“满客”提示。
思路：（该题主是酒店床位分配问题）
主要要注意的是
1.先初始化，设定房间的等级，每个等级的房间数、一个该等级房间的床位数；然后创建链表。
2.分配房间时要注意有没有住人，若有的话，该房间的性别就设定了，而如果没有，则性别可以任意。分别设置男1，女0，没人-1（或个人习惯）
3.设定订房系统时根据要求分配房间，分配成功时打印个人信息，分配不成功时，返回主界面；当出现某个等级的房间满客时应当给出提醒；整个酒店满客时订房系统没法进行操作，提示满客。
4.退房时核对个人信息，如果信息错误，则退房失败，返回主界面。退房成功是显示欢迎下次光临
5.为了方便旅客，可以设置一个简单的查询int 住店情况，比如某等级的房间住了多少人以及性别，但不能泄露住店人的信息。

 
** 题目7：文本文件单词的检索及计数（学时：6）
要求编程建立一个文本文件，每个单词不包括空格及跨行，单词由字符序列构成且区分大小写，完成以下功能：统计给定单词在文本文件中出现的总次数、检索输出某单词在文本文件中首次出现的行号及位置。
思路：（本题主要考查文件，单词查找等知识）
文件的部分上面题目已经涉及到了，对于单词查找和定位采取以下手段：
对于文件中的内容，采取一个字符一个字符的读出，若是非空格且非回车，则记录下来，存入a[i]中，直到读到空格或回车为止，将a[i]赋值为’\0’，则可以将a字符数组直接当做字符串处理，以便能够直接调用strcmp()来比较大小看是否是要查找的单词；此外，在读到空格时调整单词是该行的个数加一（另外注意如果出现连续的空格处理）；读到回车符时，行数要加一；
细节注意：1.在一个单词结束时要将i赋值为0，以待下一个单词开始；2.对于出现多个空格处理，即出现空格，先看i是否为0，若不为0，表示a中有单词，即单词个数要加一，若i为0，则表示a中没有单词，则表示之前一个字符也是空格，或是回车，则单词数不用加一；3.对于读到回车时，要将行数（line）加一，i归零，然后改行的第几个（num）也初始化为0或1看个人程序；4.在读入文件时以比如说‘#’结尾，则读到‘#’时，可以向文件中读入一个‘\n’符，不然可能会导致文件中最后一个单词读不出来（因为单词都是在遇到空格或是回车结束的，如果输入时直接在最后一个单词后面加一个‘#’而不是回车在加‘#’，回导致最后一个单词没法结束。）
 
** 题目8：二叉树的遍历（学时：6）
二叉树以lson-rson链接方式存储，以菜单方式设计并完成功能任务：建立并存储树、输出前序遍历结果、输出中序遍历结果、输出后序遍历结果、交换左右子树、统计高度，其中对于中序、后序的遍历运算要求采用非递归方式。
思路：（该题考察了二叉树的创建和遍历，交换字数，求高度等知识）
对于建树，可以有多种方式，比如可以先序建树，即输入数据，创建结点，继续输入的数据继续存入左孩子，直到出现某个字符（比如说‘#’）表示结点为空，则继续创建右孩子，直到整个树创建结束；也可用由上而下的方式创建，遇到‘#’表示该结点为空（依照个人习惯）。
先序遍历直接运用递归即可；
void preorder(BITREE *root)                              //递归实现先序遍历
{
	if (root!=NULL)
	{
		printf("%s ",root->data);                        //输出根结点
	    preorder(root->lson);                            //先序遍历左结点
	    preorder(root->rson);                            //先序遍历右结点
	}
	else return;
}
对于中序遍历，采用非递归的形式，采用根结点进栈出栈的方式模拟递归即可：
void inorder(BITREE *root)                               //非递归实现中序遍历
{
	int i=0;
	BITREE *p,*a[100];
	p=root;
	while (i!=0 || p!=NULL)                              //终止条件
	{
		while (p!=NULL)                                  //一直访到左孩子为空结点
		{
			i++;                                         //进栈
			a[i]=p;
			p=p->lson;
		}
		if (i!=0)                                        //栈不为空，则输出根结点
		{
			p=a[i];
			i--;                                         //出栈
			printf("%s ",p->data);
			p=p->rson;                                   //访问根的右孩子
		}
	}
}
对于后序遍历，由于根结点得在访问完左右孩子之后才能访问，所以可采取加标记的方式：
void postorder(BITREE *root)                             //非递归实现后序遍历
{
	BITREE *p,*a[100];
	int i=0,b[100];
	p=root; a[0]=NULL;                                   //a用来存放根结点
	while (i!=0 || p!=NULL)                              //终止条件
	{
		while (p!=NULL)                                  //访问到左孩子为空结点
		{
			if (b[i]==2) break;                          //被第二次访问的，退出，进入到输出
			i++;
			a[i]=p;
			b[i]=0;
			p=p->lson;
		}
		if (i!=0)                                        //如果栈中有元素
		{
			if (p==NULL)                                 //孩子为空的情况，则返回访问了一次，b[i]++,p回到根结点
			{ b[i]++; p=a[i];}
			if (b[i]==2)                                 //返回了两次，则输出根结点
			{ 
			  printf("%s ",p->data); 
			  b[i]=0;  i--;
			  p=a[i]; b[i]++;
			}
			if (i==0) {p=NULL; break; }                  //处理了总的根结点，特殊处理
			if (b[i]==1) p=p->rson;		                 //如果是左孩子返回的根结点，则访问该结点的右孩子
		}
	}
}
该处采取的加标记的方式是：由于访问完左孩子要返回根结点，访问完右孩子也要返回根结点，返回两次时则输出改结点，注意，对于空节点返回，同样如此，所以，所有结点都进栈，包括叶结点。然后依次出栈。
交换左右子树时，可以利用先序遍历的方式，将遍历输出的步骤改成交换左右子树的过程，即：
void exchange(BITREE *root)                              //递归实现左右子树的交换
{
	BITREE *p;
	if (root==NULL) return;                              //交换根结点的左右子树
	p=root->lson;
	root->lson=root->rson;
	root->rson=p;
	exchange(root->lson);                                //交换左孩子的子树
	exchange(root->rson);                                //交换右孩子的子树
}
而对于统计高度，同样可以用先序遍历的方式，将遍历输出的步骤改成求高度的过程：
int height(BITREE *root)                                 //递归求二叉树的高度
{
	int maxh=0,h1,h2;
	if (root!=NULL)
	{
		h1=height(root->lson);                           //h1记录左子树的高度
		h2=height(root->rson);                           //h2记录右子树的高度
		maxh=h1>h2?h1+1:h2+1;                            //树的高度等于左子树和右子树中较大的高度+1
	}
	return maxh;                                         //返回高度，若子树都是空的，则返回子树的高度为0
}

 
** 题目9：创建二叉排序树（学时：3）
二叉排序树以lson-rson链接方式存储，编写能够通过键盘输入建立二叉排序树，并在建立完立即在屏幕显示中序遍历结果的程序。
思路：（该题考察的是二叉排序树的创建）
对于二叉排序树，即根结点的左结点均小于根结点，根结点的右子结点都大于根结点（或反之）；而在每一次插入一个结点时只需要与根结点比较，若比根结点小，则往左子树上插入，直到某一子树为空时，即该处为插入结点的位置，可以发现，每次插入新节点的位置都是叶结点。
BINODE Insert(BINODE root,BINODE son)                             //排序插入结点
{
	if (root==NULL) root=son;
	else                                                          //跟为空的时候返回
	{
		if (son->data<root->data)                                 //如果小于根结点的数据
			root->lson=Insert(root->lson,son);                    //以左孩子为新的根，继续往左插入
		else if (son->data>=root->data)                           //如果大于等于根结点数据
			root->rson=Insert(root->rson,son);                    //以有孩子为新的根，往右树插入
	}
	return root;
}
而最后中序遍历时就是从小到大的顺序（或是从大到小）。
 
 
** 题目10：霍夫曼编码应用（学时：3）
假设一串由大写字母构成的电文，采用霍夫曼规则对其进行编码，以菜单方式设计并完成功能任务：建立霍夫曼树、霍夫曼编码生成、编码文件译码。
思路：（该题考察的是霍夫曼树，霍夫曼编码等知识）
创建霍夫曼树可以采取静态存储也可采取动态存储，书本上采取的是静态存储。对于给定的一组密文，根据出现的次数建立霍夫曼树。
建树过程：
 
将n个结点看做n个二叉树组成的森林，每次找出权值最小的两个二叉树，组成新的二叉树（新的二叉树的权值等于两个子结点的权值之和），然后在新的二叉树和原来剩下的二叉树中重复此操作直到组成一颗二叉树为止。
	while (ch!='\n'){                                  //读入的电文出现几次，将权设置成多少
		i=0;
		while(i<=len)
			if (a[i]->ch==ch){
				a[i]->weight++; 
				break;//break; 
			}
			else i++;
		if (i>len){
			a[i]=malloc(LEN);
			a[i]->parent=0;
			a[i]->weight=1;
			a[i]->lson=a[i]->rson=NULL;
			a[i]->ch=ch;
			len++;
		}
		ch=getchar();
	}
	for (i=len+1; i<=2*len; i++){                         //从len+1到2*len的权值都为0
		a[i]=malloc(LEN);
		a[i]->parent=0;
		a[i]->weight=0;
		a[i]->lson=a[i]->rson=NULL;
	}
	for (i=len+1; i<=2*len; i++){                         //将权只最小的两个结点合成一个结点，并且新的结点继续加入到所有结点中再次找最小的两个结点
		min1=min2=-1;
		weight1=weight2=32767;
		for (j=0; j<i; j++){
			if (a[j]->parent==0){
				if (a[j]->weight<weight1){
					weight2=weight1;                      //a[i]的权比weight1小，则肯定比min1和min2都小
					min2=min1;
					weight1=a[j]->weight;
					min1=j;
				}
				else if(a[j]->weight<weight2){
					weight2=a[j]->weight;
					min2=j;
				}
			}
		}
		a[i]->weight=weight1+weight2;
		a[min1]->parent=a[min2]->parent=i;
		a[i]->lson=a[min1];
		a[i]->rson=a[min2];
	}
而在生成编码时 ，约定左分支表示字符‘0’，右分支表示字符‘1’，字可以从根结点到叶结点的路径上分支字符组成的字符串作为该叶子结点字符的编码，显然霍夫曼编码是前缀编码（即满足每一次编码都不是另一个字符编码的前缀）
译码时从根结点除法，遇到0，则往左子树，遇到1，则往右子树，直到为叶结点时，译出一个编码，重复此操作，直到译完为止。
 
** 题目11：关键路径寻找（学时：6）
对于给定的一个工程施工图，该图以边为单位从键盘输入，编写能够找出该图的关键路径的程序。
思路：（该题考察了关键路径的相关知识）
关键路径指的是:任务计划作业图上的需要时间最长的路径（可有多条)，它决定了完成总任务的时间。
 
事件vi能够发声的最早时间：从十点v1到vi的最长路径的长，它决定了表示改时间的这个顶点发出去的所有边表示的活动的最早开始事件。
用ei表示活动的最早开始时间，li表示最迟开始时间。
用ei-li表示活动ai的时间余量，（即ai在不影响总工期的前提下，可以延缓的时间）
ei==li表示活动ai成为关键活动，显然关键路径上的所有活动都是关键活动，要加快工期只能提速关键活动的速度。
（1）从ve（1）=0 开始向前递推ve（j），可以用拓扑排序的方法按照递推顺序求出；
Ve（j）=max{ve(i)+dut(<i, j>)}    2<=j<=n    由于是求max，所以ve[1..n]初始均可置为0；
（2）从vl（n）=ve（n）起，向后递推求vl(i)，若将前一过程得到的拓扑序列存储的话，可以按照反向策略，用逆拓扑序列后退求出
Vl（i）=min{vl(j)-dut(<i, j>)}     1<=i<=n-1   由于是求min，所以vl[1..n]初始均值为ve[n]
注意：在有多条关键路径是输出可以采用遍历的方式，遇到关键活动是就往下遍历，遍历到终点时再回溯。但只能回溯到某一关键路径，比如下图的7先回溯到5，然后5再遍历到8，又是一条关键路径但是，5之前的关键活动却没法输出，所以可以开辟一个栈，将5之前的存储起来，每次回溯时出栈，遍历时进栈，这样就可以将所有的关键路径输出来。
 
void print(enode dig[],int first)              //enode是邻接表，first是始点的下标
{
	int i,j;
	static int top=0,list[50];
	vexnode * q;
		i=first;
		q=dig[i].link;
		list[top]=dig[i].vertex;
		top++;                                                  //进栈
		if (q==NULL) 
		{
			printf("%d",list[0]); 
			for (i=1;i<top;i++) printf("->%d",list[i]);
			printf("\n");
		}
		while (q!=NULL)
		{
			j=q->adjvex;
			if (dig[j].ee==dig[j].el)
			{
				list[top]=dig[j].vertex;
				print(dig,j);
			}
			q=q->next;
		}
		top--;
}

 
** 题目12：堆排序实现（学时：3）
假设有一个数据类型为整型的一维数组A，A 中的数据元素呈无序状态，编写一个采用堆排序法将A中的数据元素按由小到大进行排序的程序。
思路：
堆排序定义：n个元素的序列{k1,k2………kn}当且仅当满足下列关系时称之为堆。
{k[i]<=k[2i], k[i]<=k[2i+1]} 或者 {k[i]>=k[2i], k[i]>=k[2i+1]}若将和此序列对应的以为数组（即以一位数组作为此序列的存储结构）看成是一个完全二叉树，则堆含义表明，完全二叉树中所有飞终端结点的值均不大于（或不小于）其左右孩子结点的值。所以，若序列{k1,k2………kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值。
1.在堆中插入结点的算法思路：（假设是小堆顶，即跟的关键字小于孩子的堆）
先将该元素插入到堆底，然后与父亲比较，如果比父亲小则交换，直到比父亲大或没有父亲结点为止。可以利用此插入算法建堆。
2.在堆中删除结点的算法思路：（同样假设是下堆顶）
将该元素与堆底交换，然后调整，即先将k[i]<-k[n];然后k[i]与左右孩子比较，若比孩子小，则跟较小的孩子交换，（即，k[i]比孩子小，则j=2i 或者 2i+1，中使得k[j]是孩子中较小的，然后，i<-j，继续调整k[i]，直到父节点满足比两个孩子结点都小或没有孩子结点为止）。
3.该算法已经可以设计出来，然后由2中算法可知，能够用2中的调整的方法去建堆而取代1中的方法。即for i<-[n/2] downto 1 执行调整，然后堆就建完了，然后每次取出堆顶的元素即为最小的，而后执行2，直到结束。
（可以采取一个小技巧来节省空间，降低空间复杂度，因为堆顶的元素取出来后，堆底的元素放到了堆顶，然后堆底的那个空间就没有用了，此时可以将改空间利用起来，存放每一次的堆顶取出来的元素，则节省了空间，那么进行从小到大的堆排序时就可以采取大堆顶的方式，则，每次取出最大的，然后放入堆底，做完时该数组就是从小到大的顺序了已经。）
 

 
** 题目13基数排序的实现（学时：3）
A为每个关键字不超过3位的十进制整数关键字集合，试编写一个采用静态链表组织模式实现的基数排序程序将A进行由小到大的排序。
思路：（本题主要考察的是基数排序的问题）；
基数排序法又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的比较性排序法。
下面举例说明算法思路
以LSD为例，假设原来有一串数值如下所示：
73, 22, 93, 43, 55, 14, 28, 65, 39, 81
首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：
0
1 81
2 22
3 73 93 43
4 14
5 55 65
6
7
8 28
9 39
第二步
接下来将这些桶子中的数值重新串接起来，成为以下的数列：
81, 22, 73, 93, 43, 14, 55, 65, 28, 39
接着再进行一次分配，这次是根据十位数来分配：
0
1 14
2 22 28
3 39
4 43
5 55
6 65
7 73
8 81
9 93
第三步
接下来将这些桶子中的数值重新串接起来，成为以下的数列：
14, 22, 28, 39, 43, 55, 65, 73, 81, 93
这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。当然本题关键字最多只有3位。
然后要注意的是本题要求是静态链表组织模式。
当然也可以从高位开始，方法类类似。
